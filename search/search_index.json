{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quick Api Client","text":"<p>A library for creating fully typed declarative API clients quickly and easily.</p> <ul> <li>Github repository: https://github.com/martinn/quickapiclient/</li> <li>Documentation https://martinn.github.io/quickapiclient/</li> </ul>"},{"location":"#a-quick-example","title":"A quick example","text":"<p>An API definition for a simple service could look like this:</p> Python<pre><code>from dataclasses import dataclass\nimport quickapi\n\n\n# An example type that will be part of the API response\n@dataclass\nclass Fact:\n    fact: str\n    length: int\n\n\n# What the API response should look like\n@dataclass\nclass ResponseBody:\n    current_page: int\n    data: list[Fact]\n\n\n# Now we can define our API\nclass MyApi(quickapi.BaseApi[ResponseBody]):\n    url = \"https://catfact.ninja/facts\"\n    response_body = ResponseBody\n</code></pre> <p>And you would use it like this:</p> Python<pre><code>api_client = MyApi()\nresponse = api_client.execute()\n\n# That's it! Now `response` is fully typed and conforms to our `ResponseBody` definition\nassert isinstance(response.body, ResponseBody)\nassert isinstance(response.body.data[0], Fact)\n</code></pre> <p>There's also support for <code>attrs</code> or <code>pydantic</code> for more complex modeling, validation or serialization support.</p> <p>Scroll down here for examples using those.</p>"},{"location":"#features","title":"Features","text":"<p>It's still early development but so far we have support for:</p> <ul> <li>Write fully typed declarative API clients quickly and easily</li> <li> Fully typed request params / body</li> <li> Fully typed response body</li> <li> Serialization/deserialization support</li> <li> Basic error and serialization handling</li> <li> Nested/inner class definitions</li> <li> Improved HTTP status codes error handling</li> <li> Sessions support and/or allow building several related APIs through a single interface</li> <li> Generate API boilerplate from OpenAPI specs</li> <li> Full async support</li> <li>HTTP client libraries</li> <li> httpx</li> <li> requests</li> <li> aiohttp</li> <li>Authentication mechanisms</li> <li> Basic Auth</li> <li> Token / JWT</li> <li> Digest</li> <li> NetRC</li> <li> Any auth supported by <code>httpx</code> or httpx_auth or <code>requests</code>, including custom schemes</li> <li>Serialization/deserialization</li> <li> attrs</li> <li> dataclasses</li> <li> pydantic</li> <li>API support</li> <li> REST</li> <li> GraphQL</li> <li> Others?</li> <li>Response types supported</li> <li> JSON</li> <li> XML</li> <li> Others?</li> </ul>"},{"location":"#goal","title":"Goal","text":"<p>Eventually, I would like for the API definition to end up looking more like this (though the current approach will still be supported):</p> Python<pre><code>import quickapi\n\n\n@quickapi.define\nclass MyApi:\n    url = \"https://catfact.ninja/facts\"\n    method = quickapi.BaseApiMethod.POST\n\n    class RequestBody:\n        required_input: str\n        optional_input: str | None = None\n\n    class ResponseBody:\n        current_page: int\n        data: list[Fact]\n</code></pre> <p>And also to be able to support multiple endpoints per API client.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can easily install this using <code>pip</code>:</p> Bash Session<pre><code>pip install quickapiclient\n# Or if you want to use `attrs` over `dataclasses`:\npip install quickapiclient[attrs]\n# Or if you want to use `pydantic` over `dataclasses`:\npip install quickapiclient[pydantic]\n# Or if you want to use `requests` over `httpx`:\npip install quickapiclient[requests]\n</code></pre> <p>Or if using <code>poetry</code>:</p> Bash Session<pre><code>poetry add quickapiclient\n# Or if you want to use `attrs` over `dataclasses`:\npoetry add quickapiclient[attrs]\n# Or if you want to use `pydantic` over `dataclasses`:\npoetry add quickapiclient[pydantic]\n# Or if you want to use `requests` over `httpx`:\npoetry add quickapiclient[requests]\n</code></pre>"},{"location":"#more-examples","title":"More examples","text":""},{"location":"#a-get-request-with-query-params","title":"A GET request with query params","text":"<p>An example of a GET request with query parameters with overridable default values.</p> Python<pre><code>from dataclasses import dataclass\nimport quickapi\n\n\n@dataclass\nclass RequestParams:\n    max_length: int = 100\n    limit: int = 10\n\n\n@dataclass\nclass Fact:\n    fact: str\n    length: int\n\n\n@dataclass\nclass ResponseBody:\n    current_page: int\n    data: list[Fact]\n\n\nclass MyApi(quickapi.BaseApi[ResponseBody]):\n    url = \"https://catfact.ninja/facts\"\n    request_params = RequestParams\n    response_body = ResponseBody\n</code></pre> <p>And to use it:</p> Python<pre><code>client = MyApi()\n# Using default request param values\nresponse = client.execute()\n\n# Using custom request param values\nrequest_params = RequestParams(max_length=5, limit=10)\nresponse = client.execute(request_params=request_params)\n</code></pre>"},{"location":"#a-post-request","title":"A POST request","text":"<p>An example of a POST request with some optional and required data.</p> Python<pre><code>from dataclasses import dataclass\nimport quickapi\n\n\n@dataclass\nclass RequestBody:\n    required_input: str\n    optional_input: str | None = None\n\n\n@dataclass\nclass Fact:\n    fact: str\n    length: int\n\n\n@dataclass\nclass ResponseBody:\n    current_page: int\n    data: list[Fact]\n\n\nclass MyApi(quickapi.BaseApi[ResponseBody]):\n    url = \"https://catfact.ninja/facts\"\n    method = quickapi.BaseApiMethod.POST\n    request_body = RequestBody\n    response_body = ResponseBody\n</code></pre> <p>And to use it:</p> Python<pre><code>client = MyApi()\nrequest_body = RequestBody(required_input=\"dummy\")\nresponse = client.execute(request_body=request_body)\n</code></pre>"},{"location":"#a-post-request-with-authentication","title":"A POST request with authentication","text":"<p>An example of a POST request with HTTP header API key.</p> Python<pre><code>from dataclasses import dataclass\nimport httpx_auth\nimport quickapi\n\n\n@dataclass\nclass RequestBody:\n    required_input: str\n    optional_input: str | None = None\n\n\n@dataclass\nclass Fact:\n    fact: str\n    length: int\n\n\n@dataclass\nclass AuthResponseBody:\n    authenticated: bool\n    user: str\n\n\nclass MyApi(quickapi.BaseApi[AuthResponseBody]):\n    url = \"https://httpbin.org/bearer\"\n    method = quickapi.BaseApiMethod.POST\n    # You could specify it here if you wanted\n    # auth = httpx_auth.HeaderApiKey(header_name=\"X-Api-Key\", api_key=\"secret_api_key\")\n    response_body = AuthResponseBody\n</code></pre> <p>And to use it:</p> Python<pre><code>client = MyApi()\nrequest_body = RequestBody(required_input=\"dummy\")\nauth = httpx_auth.HeaderApiKey(header_name=\"X-Api-Key\", api_key=\"secret_api_key\")\nresponse = client.execute(request_body=request_body, auth=auth)\n</code></pre>"},{"location":"#a-post-request-with-validation-and-conversion-using-attrs","title":"A POST request with validation and conversion (Using <code>attrs</code>)","text":"<p>An example of a POST request with custom validators and converters (using <code>attrs</code> instead).</p> Python<pre><code>import attrs\nimport quickapi\nimport enum\n\n\nclass State(enum.Enum):\n    ON = \"on\"\n    OFF = \"off\"\n\n\n@attrs.define\nclass RequestBody:\n    state: State = attrs.field(validator=attrs.validators.in_(State))\n    email: str = attrs.field(\n        validator=attrs.validators.matches_re(\n            r\"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$)\"\n        )\n    )\n\n\n@attrs.define\nclass ResponseBody:\n    success: bool = attrs.field(converter=attrs.converters.to_bool)\n\n\nclass MyApi(quickapi.BaseApi[ResponseBody]):\n    url = \"https://example.com/\"\n    method = quickapi.BaseApiMethod.POST\n    request_body = RequestBody\n    response_body = ResponseBody\n</code></pre> <p>And to use it:</p> Python<pre><code>client = MyApi()\nrequest_body = RequestBody(email=\"invalid_email\", state=\"on\") # Will raise an error\nresponse = client.execute(request_body=request_body)\n</code></pre> <p>Check out attrs for full configuration.</p>"},{"location":"#a-post-request-with-validation-and-conversion-using-pydantic","title":"A POST request with validation and conversion (Using <code>pydantic</code>)","text":"<p>An example of a POST request with custom validators and converters (using <code>pydantic</code> instead).</p> Python<pre><code>import enum\nimport pydantic\nimport quickapi\n\n\nclass State(enum.Enum):\n    ON = \"on\"\n    OFF = \"off\"\n\n\nclass RequestBody(pydantic.BaseModel):\n    state: State\n    email: pydantic.EmailStr\n\n\nclass ResponseBody(pydantic.BaseModel):\n    success: bool\n\n\nclass MyApi(quickapi.BaseApi[ResponseBody]):\n    url = \"https://example.com/\"\n    method = quickapi.BaseApiMethod.POST\n    request_body = RequestBody\n    response_body = ResponseBody\n</code></pre> <p>And to use it:</p> Python<pre><code>client = MyApi()\nrequest_body = RequestBody(email=\"invalid_email\", state=\"on\") # Will raise an error\nresponse = client.execute(request_body=request_body)\n</code></pre> <p>Check out pydantic for full configuration.</p>"},{"location":"#using-requests-library","title":"Using <code>requests</code> library","text":"<p>An example of a GET request using the <code>requests</code> HTTP library instead of <code>HTTPx</code>.</p> Python<pre><code>from dataclasses import dataclass\nimport quickapi\n\n\n@dataclass\nclass ResponseBody:\n    current_page: int\n    data: list[Fact]\n\n\nclass MyApi(quickapi.BaseApi[ResponseBody]):\n    url = \"https://catfact.ninja/facts\"\n    response_body = ResponseBody\n    http_client = quickapi.RequestsClient()\n</code></pre> <p>And to use it:</p> Python<pre><code>client = MyApi()\nresponse = client.execute()\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcomed, and greatly appreciated!</p> <p>The easiest way to contribute, if you found this useful or interesting, is by giving it a star! \ud83c\udf1f</p> <p>Otherwise, check out the contributing guide for how else to help and get started.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to <code>quickapiclient</code>","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"CONTRIBUTING/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"CONTRIBUTING/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/martinn/quickapiclient/issues</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"CONTRIBUTING/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement a fix for it.</p>"},{"location":"CONTRIBUTING/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"CONTRIBUTING/#write-documentation","title":"Write Documentation","text":"<p>quickapiclient could always use more documentation, whether as part of the official docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"CONTRIBUTING/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/martinn/quickapiclient/issues.</p> <p>If you are proposing a new feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"CONTRIBUTING/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>quickapiclient</code> for local development. Please note this documentation assumes you already have <code>poetry</code> and <code>Git</code> installed and ready to go.</p> <ol> <li> <p>Fork the <code>quickapiclient</code> repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> </li> </ol> Bash<pre><code>cd &lt;directory_in_which_repo_should_be_created&gt;\ngit clone git@github.com:YOUR_NAME/quickapiclient.git\n</code></pre> <ol> <li>Now we need to install the environment. Navigate into the directory</li> </ol> Bash<pre><code>cd quickapiclient\n</code></pre> <p>If you are using <code>pyenv</code>, select a version to use locally. (See installed versions with <code>pyenv versions</code>)</p> Bash<pre><code>pyenv local &lt;x.y.z&gt;\n</code></pre> <p>Then, install, activate the environment and setup pre-commit with:</p> Bash<pre><code>make install\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> Bash<pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li> <p>Don't forget to add test cases for your added functionality to the <code>tests</code> directory.</p> </li> <li> <p>When you're done making changes, check that your changes pass the formatting tests.</p> </li> </ol> Bash<pre><code>make check\n</code></pre> <p>Now, validate that all unit tests are passing:</p> Bash<pre><code>make test\n</code></pre> <ol> <li>Before raising a pull request you should also run tox.    This will run the tests across different versions of Python:</li> </ol> Bash<pre><code>tox\n</code></pre> <p>This requires you to have multiple versions of python installed. This step is also triggered in the CI/CD pipeline, so you could also choose to skip this step locally.</p> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> Bash<pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"CONTRIBUTING/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li> <p>The pull request should include tests.</p> </li> <li> <p>If the pull request adds functionality, the docs should be updated.</p> </li> </ol>"},{"location":"api_reference/","title":"API reference","text":""},{"location":"api_reference/#quickapi.client.BaseApi","title":"<code>BaseApi</code>","text":"<p>             Bases: <code>Generic[ResponseBodyT]</code></p> <p>Base class for all API clients.</p> Source code in <code>quickapi/client.py</code> Python<pre><code>class BaseApi(Generic[ResponseBodyT]):\n    \"\"\"Base class for all API clients.\"\"\"\n\n    url: str\n    method: BaseApiMethod = BaseApiMethod.GET\n    auth: BaseHttpClientAuth = None\n    request_params: type[DictSerializableT] | None = None\n    request_body: type[DictSerializableT] | None = None\n    response_body: type[ResponseBodyT]\n    http_client: BaseHttpClient | None = None\n\n    _http_client: BaseHttpClient = HTTPxClient()\n    _request_params: \"DictSerializableT | None\" = None\n    _request_body: \"DictSerializableT | None\" = None\n    _response_body_cls: type[ResponseBodyT]\n    _response: BaseResponse[ResponseBodyT] | None = None\n\n    @classmethod\n    def __init_subclass__(cls, **kwargs: object) -&gt; None:\n        super().__init_subclass__(**kwargs)\n        cls._validate_subclass()\n\n        if cls.request_params is not None:\n            cls._request_params = cls.request_params()\n\n        if cls.request_body is not None:\n            cls._request_body = cls.request_body()\n\n        cls._response_body_cls = cls.response_body  # pyright: ignore [reportGeneralTypeIssues]\n\n        if cls.http_client is not None:\n            cls._http_client = cls.http_client\n\n    @classmethod\n    def _validate_subclass(cls) -&gt; None:\n        if getattr(cls, \"url\", None) is None:\n            raise ClientSetupError(attribute=\"url\")\n\n        if getattr(cls, \"response_body\", None) is None:\n            raise ClientSetupError(attribute=\"response_body\")\n\n        if (\n            getattr(cls, \"method\", None) is not None\n            and cls.method not in BaseApiMethod.values()\n        ):\n            raise ClientSetupError(attribute=\"method\")\n\n        if getattr(cls, \"http_client\", None) is not None and not (\n            isinstance(cls.http_client, BaseHttpClient)\n        ):\n            raise ClientSetupError(attribute=\"http_client\")\n\n        if getattr(cls, \"__orig_bases__\", None) is not None:\n            response_body_generic_type = get_args(cls.__orig_bases__[0])[0]  # type: ignore [attr-defined]\n            if (\n                isinstance(response_body_generic_type, TypeVar)\n                and response_body_generic_type.__name__ == \"ResponseBodyT\"\n            ):\n                raise ClientSetupError(attribute=\"ResponseBodyT\")\n\n    def __init__(\n        self,\n        request_params: \"DictSerializableT | None\" = None,\n        request_body: \"DictSerializableT | None\" = None,\n        http_client: BaseHttpClient | None = None,\n        auth: BaseHttpClientAuth = USE_DEFAULT,\n    ) -&gt; None:\n        self._request_params = request_params or self._request_params\n        self._request_body = request_body or self._request_body\n        self._http_client = http_client or self._http_client\n        self.auth = auth if auth != USE_DEFAULT else self.auth\n\n    def execute(\n        self,\n        request_params: \"DictSerializableT | None\" = None,\n        request_body: \"DictSerializableT | None\" = None,\n        http_client: BaseHttpClient | None = None,\n        auth: BaseHttpClientAuth = USE_DEFAULT,\n    ) -&gt; BaseResponse[ResponseBodyT]:\n        \"\"\"Execute the API request and return the response.\"\"\"\n\n        self._request_params = request_params or self._request_params\n        self._request_body = request_body or self._request_body\n        self._http_client = http_client or self._http_client\n        self.auth = auth if auth != USE_DEFAULT else self.auth\n        try:\n            params = (\n                DictSerializable.to_dict(self._request_params)\n                if self._request_params\n                else {}\n            )\n            json = (\n                DictSerializable.to_dict(self._request_body)\n                if self._request_body\n                else {}\n            )\n        except DictDeserializationError as e:\n            raise RequestSerializationError(expected_type=e.expected_type) from e\n\n        match self.method:\n            case BaseApiMethod.GET:\n                client_response = self._http_client.get(\n                    url=self.url,\n                    auth=self.auth,\n                    params=params,\n                )\n            case BaseApiMethod.OPTIONS:\n                client_response = self._http_client.options(\n                    url=self.url,\n                    auth=self.auth,\n                    params=params,\n                )\n            case BaseApiMethod.HEAD:\n                client_response = self._http_client.head(\n                    url=self.url,\n                    auth=self.auth,\n                    params=params,\n                )\n            case BaseApiMethod.POST:\n                client_response = self._http_client.post(\n                    url=self.url,\n                    auth=self.auth,\n                    params=params,\n                    json=json,\n                )\n            case BaseApiMethod.PUT:\n                client_response = self._http_client.put(\n                    url=self.url,\n                    auth=self.auth,\n                    params=params,\n                    json=json,\n                )\n            case BaseApiMethod.PATCH:\n                client_response = self._http_client.patch(\n                    url=self.url,\n                    auth=self.auth,\n                    params=params,\n                    json=json,\n                )\n            case BaseApiMethod.DELETE:\n                client_response = self._http_client.delete(\n                    url=self.url,\n                    auth=self.auth,\n                    params=params,\n                )\n            case _:\n                raise NotImplementedError(f\"Method {self.method} not implemented.\")\n\n        # TODO: Add support for handling different response status codes\n        if client_response.status_code != 200:\n            raise HTTPError(client_response.status_code)\n\n        try:\n            body = DictSerializable.from_dict(\n                self._response_body_cls, client_response.json()\n            )\n        except DictSerializationError as e:\n            raise ResponseSerializationError(expected_type=e.expected_type) from e\n\n        self._response = BaseResponse(client_response=client_response, body=body)\n\n        return self._response\n</code></pre>"},{"location":"api_reference/#quickapi.client.BaseApi.execute","title":"<code>execute(request_params=None, request_body=None, http_client=None, auth=USE_DEFAULT)</code>","text":"<p>Execute the API request and return the response.</p> Source code in <code>quickapi/client.py</code> Python<pre><code>def execute(\n    self,\n    request_params: \"DictSerializableT | None\" = None,\n    request_body: \"DictSerializableT | None\" = None,\n    http_client: BaseHttpClient | None = None,\n    auth: BaseHttpClientAuth = USE_DEFAULT,\n) -&gt; BaseResponse[ResponseBodyT]:\n    \"\"\"Execute the API request and return the response.\"\"\"\n\n    self._request_params = request_params or self._request_params\n    self._request_body = request_body or self._request_body\n    self._http_client = http_client or self._http_client\n    self.auth = auth if auth != USE_DEFAULT else self.auth\n    try:\n        params = (\n            DictSerializable.to_dict(self._request_params)\n            if self._request_params\n            else {}\n        )\n        json = (\n            DictSerializable.to_dict(self._request_body)\n            if self._request_body\n            else {}\n        )\n    except DictDeserializationError as e:\n        raise RequestSerializationError(expected_type=e.expected_type) from e\n\n    match self.method:\n        case BaseApiMethod.GET:\n            client_response = self._http_client.get(\n                url=self.url,\n                auth=self.auth,\n                params=params,\n            )\n        case BaseApiMethod.OPTIONS:\n            client_response = self._http_client.options(\n                url=self.url,\n                auth=self.auth,\n                params=params,\n            )\n        case BaseApiMethod.HEAD:\n            client_response = self._http_client.head(\n                url=self.url,\n                auth=self.auth,\n                params=params,\n            )\n        case BaseApiMethod.POST:\n            client_response = self._http_client.post(\n                url=self.url,\n                auth=self.auth,\n                params=params,\n                json=json,\n            )\n        case BaseApiMethod.PUT:\n            client_response = self._http_client.put(\n                url=self.url,\n                auth=self.auth,\n                params=params,\n                json=json,\n            )\n        case BaseApiMethod.PATCH:\n            client_response = self._http_client.patch(\n                url=self.url,\n                auth=self.auth,\n                params=params,\n                json=json,\n            )\n        case BaseApiMethod.DELETE:\n            client_response = self._http_client.delete(\n                url=self.url,\n                auth=self.auth,\n                params=params,\n            )\n        case _:\n            raise NotImplementedError(f\"Method {self.method} not implemented.\")\n\n    # TODO: Add support for handling different response status codes\n    if client_response.status_code != 200:\n        raise HTTPError(client_response.status_code)\n\n    try:\n        body = DictSerializable.from_dict(\n            self._response_body_cls, client_response.json()\n        )\n    except DictSerializationError as e:\n        raise ResponseSerializationError(expected_type=e.expected_type) from e\n\n    self._response = BaseResponse(client_response=client_response, body=body)\n\n    return self._response\n</code></pre>"},{"location":"api_reference/#quickapi.client.BaseApiMethod","title":"<code>BaseApiMethod</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Supported HTTP methods.</p> Source code in <code>quickapi/client.py</code> Python<pre><code>class BaseApiMethod(str, Enum):\n    \"\"\"Supported HTTP methods.\"\"\"\n\n    GET = \"GET\"\n    POST = \"POST\"\n    PUT = \"PUT\"\n    DELETE = \"DELETE\"\n    PATCH = \"PATCH\"\n    OPTIONS = \"OPTIONS\"\n    HEAD = \"HEAD\"\n    TRACE = \"TRACE\"\n\n    @staticmethod\n    def values() -&gt; dict[str, Enum]:\n        return BaseApiMethod._value2member_map_\n</code></pre>"},{"location":"api_reference/#quickapi.exceptions.ClientSetupError","title":"<code>ClientSetupError</code>","text":"<p>             Bases: <code>QuickApiException</code></p> <p>An error setting up the BaseClient subclass.</p> Source code in <code>quickapi/exceptions.py</code> Python<pre><code>class ClientSetupError(QuickApiException):\n    \"\"\"An error setting up the BaseClient subclass.\"\"\"\n\n    def __init__(self, attribute: str):\n        message = f\"Subclass setup error. Missing or invalid required attribute `{attribute}`.\"\n        super().__init__(message)\n</code></pre>"},{"location":"api_reference/#quickapi.exceptions.DictDeserializationError","title":"<code>DictDeserializationError</code>","text":"<p>             Bases: <code>QuickApiException</code></p> <p>Dict deserialization failed.</p> Source code in <code>quickapi/exceptions.py</code> Python<pre><code>class DictDeserializationError(QuickApiException):\n    \"\"\"Dict deserialization failed.\"\"\"\n\n    expected_type = \"\"\n\n    def __init__(self, expected_type: str):\n        self.expected_type = expected_type\n        super().__init__(self.__doc__)\n</code></pre>"},{"location":"api_reference/#quickapi.exceptions.DictSerializationError","title":"<code>DictSerializationError</code>","text":"<p>             Bases: <code>QuickApiException</code></p> <p>Dict serialization failed.</p> Source code in <code>quickapi/exceptions.py</code> Python<pre><code>class DictSerializationError(QuickApiException):\n    \"\"\"Dict serialization failed.\"\"\"\n\n    expected_type = \"\"\n\n    def __init__(self, expected_type: str):\n        self.expected_type = expected_type\n        super().__init__(self.__doc__)\n</code></pre>"},{"location":"api_reference/#quickapi.exceptions.HTTPError","title":"<code>HTTPError</code>","text":"<p>             Bases: <code>QuickApiException</code></p> <p>The response received a non <code>200</code> response status code.</p> Source code in <code>quickapi/exceptions.py</code> Python<pre><code>class HTTPError(QuickApiException):\n    \"\"\"The response received a non `200` response status code.\"\"\"\n\n    def __init__(self, status_code: int):\n        message = f\"HTTP request received a non `HTTP 200 (OK)` response. The response status code was `{status_code}`.\"\n        super().__init__(message)\n</code></pre>"},{"location":"api_reference/#quickapi.exceptions.MissingDependencyError","title":"<code>MissingDependencyError</code>","text":"<p>             Bases: <code>QuickApiException</code></p> <p>Trying to use an optional dependency without installing it first.</p> Source code in <code>quickapi/exceptions.py</code> Python<pre><code>class MissingDependencyError(QuickApiException):\n    \"\"\"Trying to use an optional dependency without installing it first.\"\"\"\n\n    def __init__(self, dependency: str):\n        message = (\n            f\"Using an optional dependecy without installing it first `{dependency}`.\"\n            f\"Please install the dependency using `pip install quickapiclient[{dependency}]`.\"\n        )\n        super().__init__(message)\n</code></pre>"},{"location":"api_reference/#quickapi.exceptions.QuickApiException","title":"<code>QuickApiException</code>","text":"<p>             Bases: <code>Exception</code></p> <p>A QuickApi exception has occurred.</p> Source code in <code>quickapi/exceptions.py</code> Python<pre><code>class QuickApiException(Exception):\n    \"\"\"A QuickApi exception has occurred.\"\"\"\n</code></pre>"},{"location":"api_reference/#quickapi.exceptions.RequestSerializationError","title":"<code>RequestSerializationError</code>","text":"<p>             Bases: <code>QuickApiException</code></p> <p>The request was not serializable to the configured type.</p> Source code in <code>quickapi/exceptions.py</code> Python<pre><code>class RequestSerializationError(QuickApiException):\n    \"\"\"The request was not serializable to the configured type.\"\"\"\n\n    def __init__(self, expected_type: str):\n        message = (\n            f\"HTTP request params/body did not match expected type `{expected_type}`.\"\n        )\n        super().__init__(message)\n</code></pre>"},{"location":"api_reference/#quickapi.exceptions.ResponseSerializationError","title":"<code>ResponseSerializationError</code>","text":"<p>             Bases: <code>QuickApiException</code></p> <p>The response received was not serializable to the configured <code>response_body</code> type.</p> Source code in <code>quickapi/exceptions.py</code> Python<pre><code>class ResponseSerializationError(QuickApiException):\n    \"\"\"The response received was not serializable to the configured `response_body` type.\"\"\"\n\n    def __init__(self, expected_type: str):\n        message = f\"HTTP response body did not match expected type `{expected_type}`.\"\n        super().__init__(message)\n</code></pre>"},{"location":"api_reference/#quickapi.http_client.BaseHttpClient","title":"<code>BaseHttpClient</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base interface for all HTTP clients.</p> Source code in <code>quickapi/http_client.py</code> Python<pre><code>class BaseHttpClient(ABC):\n    \"\"\"Base interface for all HTTP clients.\"\"\"\n\n    @abstractmethod\n    def __init__(self, *args, **kwargs): ...  # type: ignore [no-untyped-def]\n\n    @abstractmethod\n    def get(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        raise NotImplementedError\n\n    @abstractmethod\n    def options(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        raise NotImplementedError\n\n    @abstractmethod\n    def head(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        raise NotImplementedError\n\n    @abstractmethod\n    def post(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        raise NotImplementedError\n\n    @abstractmethod\n    def put(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        raise NotImplementedError\n\n    @abstractmethod\n    def patch(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        raise NotImplementedError\n\n    @abstractmethod\n    def delete(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/#quickapi.http_client.HTTPxClient","title":"<code>HTTPxClient</code>","text":"<p>             Bases: <code>BaseHttpClient</code></p> <p>A thin wrapper around HTTPx. This is the default client.</p> Source code in <code>quickapi/http_client.py</code> Python<pre><code>class HTTPxClient(BaseHttpClient):\n    \"\"\"A thin wrapper around HTTPx. This is the default client.\"\"\"\n\n    def __init__(self, client: type[httpx.Client] | None = None):\n        self._client = client or httpx.Client()\n\n    def get(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        return self._client.get(*args, **kwargs)\n\n    def options(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        return self._client.options(*args, **kwargs)\n\n    def head(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        return self._client.head(*args, **kwargs)\n\n    def post(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        return self._client.post(*args, **kwargs)\n\n    def put(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        return self._client.put(*args, **kwargs)\n\n    def patch(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        return self._client.patch(*args, **kwargs)\n\n    def delete(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        return self._client.delete(*args, **kwargs)\n</code></pre>"},{"location":"api_reference/#quickapi.http_client.RequestsClient","title":"<code>RequestsClient</code>","text":"<p>             Bases: <code>BaseHttpClient</code></p> <p>A thin wrapper around requests.</p> <p>This client is only available if the requests library is installed with: <code>pip install quickapiclient[requests]</code> or <code>poetry add quickapiclient[requests]</code>.</p> Source code in <code>quickapi/http_client.py</code> Python<pre><code>class RequestsClient(BaseHttpClient):\n    \"\"\"\n    A thin wrapper around requests.\n\n    This client is only available if the requests library is installed with:\n    `pip install quickapiclient[requests]`\n    or `poetry add quickapiclient[requests]`.\n    \"\"\"\n\n    def __init__(self, client: type[\"requests.sessions.Session\"] | None = None):\n        if requests_installed is False:\n            raise MissingDependencyError(dependency=\"requests\")\n\n        self._client = client or requests.sessions.Session()\n\n    def get(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        return self._client.get(*args, **kwargs)\n\n    def options(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        return self._client.options(*args, **kwargs)\n\n    def head(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        return self._client.head(*args, **kwargs)\n\n    def post(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        return self._client.post(*args, **kwargs)\n\n    def put(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        return self._client.put(*args, **kwargs)\n\n    def patch(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        return self._client.patch(*args, **kwargs)\n\n    def delete(self, *args, **kwargs):  # type: ignore [no-untyped-def]\n        return self._client.delete(*args, **kwargs)\n</code></pre>"},{"location":"api_reference/#quickapi.serializers.AttrsDeserializer","title":"<code>AttrsDeserializer</code>","text":"<p>Convert from attrs model to dict.</p> Source code in <code>quickapi/serializers.py</code> Python<pre><code>class AttrsDeserializer:\n    \"\"\"\n    Convert from attrs model to dict.\n    \"\"\"\n\n    @classmethod\n    def can_apply(cls, instance: \"attrs.AttrsInstance\") -&gt; bool:\n        return attrs.has(type(instance))\n\n    @classmethod\n    def to_dict(cls, instance: \"attrs.AttrsInstance\") -&gt; dict | None:\n        return attrs.asdict(instance)\n</code></pre>"},{"location":"api_reference/#quickapi.serializers.AttrsSerializer","title":"<code>AttrsSerializer</code>","text":"<p>Convert from dict to attrs model.</p> Source code in <code>quickapi/serializers.py</code> Python<pre><code>class AttrsSerializer:\n    \"\"\"\n    Convert from dict to attrs model.\n\n    \"\"\"\n\n    @classmethod\n    def can_apply(cls, klass: type[FromDictSerializableT]) -&gt; bool:\n        return attrs.has(klass)\n\n    @classmethod\n    def from_dict(\n        cls, klass: type[FromDictSerializableT], values: dict\n    ) -&gt; FromDictSerializableT:\n        try:\n            return cattrs.structure(values, klass)\n        except cattrs.ClassValidationError as e:\n            raise DictSerializationError(expected_type=klass.__name__) from e\n</code></pre>"},{"location":"api_reference/#quickapi.serializers.DataclassDeserializer","title":"<code>DataclassDeserializer</code>","text":"<p>Convert from dataclass model to dict.</p> Source code in <code>quickapi/serializers.py</code> Python<pre><code>class DataclassDeserializer:\n    \"\"\"\n    Convert from dataclass model to dict.\n    \"\"\"\n\n    @classmethod\n    def can_apply(cls, instance: \"DataclassInstance\") -&gt; bool:\n        return dataclasses.is_dataclass(instance)\n\n    @classmethod\n    def to_dict(cls, instance: \"DataclassInstance\") -&gt; dict | None:\n        return dataclasses.asdict(instance)\n</code></pre>"},{"location":"api_reference/#quickapi.serializers.DataclassSerializer","title":"<code>DataclassSerializer</code>","text":"<p>Convert from dict to attrs model.</p> Source code in <code>quickapi/serializers.py</code> Python<pre><code>class DataclassSerializer:\n    \"\"\"\n    Convert from dict to attrs model.\n\n    \"\"\"\n\n    @classmethod\n    def can_apply(cls, klass: type[FromDictSerializableT]) -&gt; bool:\n        return dataclasses.is_dataclass(klass)\n\n    @classmethod\n    def from_dict(\n        cls, klass: type[FromDictSerializableT], values: dict\n    ) -&gt; FromDictSerializableT:\n        try:\n            # TODO: See if there's a simpler approach so we can remove this hard dependency\n            return cattrs.structure(values, klass)\n        except cattrs.ClassValidationError as e:\n            raise DictSerializationError(expected_type=klass.__name__) from e\n</code></pre>"},{"location":"api_reference/#quickapi.serializers.DictSerializable","title":"<code>DictSerializable</code>","text":"<p>Convert to/from dictionaries to the appropriate class/instance.</p> <p>@TODO: Maybe make the (de)serializer pluggable and configurable     instead of checking which one can apply.</p> Source code in <code>quickapi/serializers.py</code> Python<pre><code>class DictSerializable:\n    \"\"\"\n    Convert to/from dictionaries to the appropriate class/instance.\n\n    @TODO: Maybe make the (de)serializer pluggable and configurable\n        instead of checking which one can apply.\n    \"\"\"\n\n    serializers: Sequence[type[BaseSerializer]] = (\n        DataclassSerializer,\n        AttrsSerializer,\n        PydanticSerializer,\n    )\n    deserializers: Sequence[type[BaseDeserializer]] = (  # type: ignore [assignment]\n        DataclassDeserializer,\n        AttrsDeserializer,\n        PydanticDeserializer,\n    )\n\n    @classmethod\n    def from_dict(\n        cls, klass: type[FromDictSerializableT], values: dict\n    ) -&gt; FromDictSerializableT:\n        for serializer in cls.serializers:\n            if serializer.can_apply(klass):\n                return serializer.from_dict(klass, values)\n        raise DictSerializationError(expected_type=klass.__name__)\n\n    @classmethod\n    def to_dict(cls, instance: DictSerializableT) -&gt; dict | None:\n        for deserializer in cls.deserializers:\n            if deserializer.can_apply(instance):\n                return deserializer.to_dict(instance)\n        raise DictDeserializationError(expected_type=str(DictSerializableT))\n</code></pre>"},{"location":"api_reference/#quickapi.serializers.PydanticDeserializer","title":"<code>PydanticDeserializer</code>","text":"<p>Convert from pydantic model to dict.</p> Source code in <code>quickapi/serializers.py</code> Python<pre><code>class PydanticDeserializer:\n    \"\"\"Convert from pydantic model to dict.\"\"\"\n\n    @classmethod\n    def can_apply(cls, instance: \"pydantic.BaseModel\") -&gt; bool:\n        return pydantic_installed and isinstance(instance, pydantic.BaseModel)\n\n    @classmethod\n    def to_dict(cls, instance: \"pydantic.BaseModel\") -&gt; dict | None:\n        return instance.model_dump()\n</code></pre>"},{"location":"api_reference/#quickapi.serializers.PydanticSerializer","title":"<code>PydanticSerializer</code>","text":"<p>Convert from dict to pydantic model.</p> Source code in <code>quickapi/serializers.py</code> Python<pre><code>class PydanticSerializer:\n    \"\"\"\n    Convert from dict to pydantic model.\n    \"\"\"\n\n    @classmethod\n    def can_apply(cls, klass: type[FromDictSerializableT]) -&gt; bool:\n        # TODO: Is this correct?\n        return pydantic_installed and issubclass(klass, pydantic.BaseModel)\n\n    @classmethod\n    def from_dict(\n        cls, klass: type[FromDictSerializableT], values: dict\n    ) -&gt; FromDictSerializableT:\n        try:\n            return klass(**values)\n        except pydantic.ValidationError as e:\n            raise DictSerializationError(expected_type=klass.__name__) from e\n</code></pre>"}]}